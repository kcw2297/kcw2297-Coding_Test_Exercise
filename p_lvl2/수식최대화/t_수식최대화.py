"""https://programmers.co.kr/learn/courses/30/lessons/67257"""


"""
접근한 논리 및 오류:
    eval()함수를 이용한다
    3!의 경우의 수가 있으니 이를 반복한다
    *dp, recursion문제로 판단하여 접근하였는데, 연산자 우선순위를 고려하니 힘듬

접근한 논리 및 오류:
    eval()함수를 이용한다
    isdigit()함수를 이용해 연산자와 피연산자 사이에 괄호로 묶음
    *어떤식으로 괄호를 묶을지 고민
    *논리 접근시 처음 원하는 연산자를 괄호를 묶는 것에 집착해 순서에 관한 유연한 생각을 못했다

정리:
    위에 접근한 논리 방식과 split() 함수를 더했다면 정답에서 사용한 논리와 같았다.
    어떤식으로 연산자를 기준으로 피연산자를 나눌지 몰라서 해맸는데, 분할 정복 문제에서는
    split()을 적극적으로 사용할 필요가 있어 보인다
"""


# 100-200*300-500+20 => 100-200  300-500+20


# = 100-(200*300)-500+20
# = 100-60000-(500+20)
# = (100-60000)-520
# = (-59900-520)
# = -60420

"100-200*300-500+20"	60420
